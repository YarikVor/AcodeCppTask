
У цьому розділі ми розглянули багато матеріалу. Якщо ви дійшли до цього моменту, то я вас вітаю — ви пройшли досить чимало і це вже хороший крок на шляху до вивчення мови C++ (і взагалі програмування)! Зараз же давайте закріпимо пройдений матеріал.

Зміст:

1.  [Теорія](https://acode.com.ua/rozdil-4-pidsumkovyj-test/#toc-0)
2.  [Тест](https://acode.com.ua/rozdil-4-pidsumkovyj-test/#toc-1)

## Теорія

**Блок стейтментів**  обробляється компілятором так, наче це один стейтмент. Блоки стейтментів розміщуються в фігурних дужках  `{`  і  `}` і використовуються майже всюди.

**Локальні змінні**  створюються в точці оголошення і знищуються при виході з блоку, в якому вони оголошені. Доступ до них можливий тільки всередині цього ж блоку.

**Глобальні змінні**  створюються, коли програма запускається, і знищуються, коли вона завершує своє виконання. Вони можуть використовуватися в будь-якому місці програми. Неконстантні глобальні змінні слід уникати, бо це — зло.

**Ключове слово static**  може використовуватися для конвертації глобальної змінної у внутрішню (з внутрішнім зв’язком), щоб її можна було використовувати тільки в тому файлі, в якому вона оголошена. Також ключове слово static використовують, щоб вказати, що локальна змінна повинна мати статичну тривалість життя. А це означає, що вона зберігатиме своє значення навіть після виходу зі своєї області видимості.

**Простір імен**  — це область, в якій гарантується унікальність всіх імен. Відмінний спосіб уникнути конфліктів імен. Не використовуйте using-стейтменти поза тілом функцій.

**Неявна конвертація типів даних**  відбувається, коли один тип даних конвертується в інший тип без використання одного з операторів конвертації.  **Явна конвертація типу**  відбувається, коли один тип даних конвертується в інший за допомогою одного з операторів конвертації. У деяких випадках це абсолютно безпечно, а в деяких випадках може відбутися втрата даних. Уникайте використання конвертації C-style, замість неї використовуйте оператор static_cast.

**std::string**  — це простий спосіб роботи з текстовими рядками (текст поміщається в подвійні лапки).

**Перерахування**  дозволяють створювати власні типи даних.

**Класи enum**  — це ті ж перерахування, але надійніші і безпечніші. Використовуйте їх замість звичайних перерахувань, якщо ваш компілятор підтримує C++11.

**typedef**  дозволяє створювати псевдоніми для типів даних. Цілочисельні типи даних з фіксованим розміром реалізовані за допомогою typedef. Псевдоніми типів корисні для присвоювання простих імен складним типам даних.

І, нарешті,  **структури**. Вони дозволяють згрупувати змінні різних типів даних в єдине ціле. Доступ до членів структури здійснюється через оператор вибору членів (`.`). Об’єктно-орієнтоване програмування в значній мірі ґрунтується саме на структурах, тому, якщо ви вивчили тільки одну тему з цього розділу, то краще, щоб це були структури.  

## Тест

При розробці гри ми вирішили, що в ній повинні бути монстри, тому що всім подобається битися з монстрами. Оголосіть структуру, яка представляє вашого монстра. Монстр може бути різним:  `ogre`,  `goblin`,  `skeleton`,  `orc` і `troll`. Якщо ваш компілятор підтримує C++11, то використовуйте класи enum, якщо ні — використовуйте звичайні перерахування.

Кожен монстр повинен мати ім’я (використовуйте std::string) і кількість здоров’я, яке відображає, скільки шкоди він може отримати, перш ніж помре. Напишіть функцію printMonster(), яка виведе всі члени структури. Оголосіть монстрів типу  `goblin` і  `orc`, ініціалізуйте їх, використовуючи список ініціалізаторів, і передайте в функцію printMonster().

Приклад результату виконання програми:

`This Goblin is named John and has 170 health.  
This Orc is named James and has 35 health.`