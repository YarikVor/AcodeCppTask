
### Завдання №1

Напишіть прототипи функцій для наступних випадків. Використовуйте const при необхідності.

a) Функція з іменем max(), яка приймає два значення типу double і повертає більше з них.

**Відповідь №1.а)**

b) Функція swap(), яка міняє місцями два цілих числа.

**Відповідь №1.b)**

c) Функція getLargestElement(), яка приймає динамічно виділений масив цілих чисел і повертає найбільше число таким чином, що caller може змінити значення елементу, що повертається (не забудьте про параметр-довжину).

**Відповідь №1.c)**

### Завдання №2

Що не так з наступними програмами?

a)

1

2

3

4

5

int&  doSomething()

{

int  array[]  =  {  1,  3,  5,  7,  9  };

return  array[2];

}

**Відповідь №2.а)**

b)

1

2

3

4

int  sumTo(int  value)

{

return  value  +  sumTo(value  -  1);

}

**Відповідь №2.b)**

c)

1

2

3

4

5

6

7

8

9

float  divide(float  a,  float  b)

{

return  a  /  b;

}

double  divide(float  a,  float  b)

{

return  a  /  b;

}

**Відповідь №2.c)**

d)

1

2

3

4

5

6

7

8

9

10

11

#include <iostream>

int  main()

{

int  array[1000000000];

for  (const  auto  &x:  array)

std::cout  <<  x  <<  ' ';

return  0;

}

**Відповідь №2.d)**

e)

1

2

3

4

5

6

7

8

9

10

#include <iostream>

int  main(int  argc,  char  *argv[])

{

int  times  =  argv[1];

for  (int  count  =  0;  count  <  times;  count++)

std::cout  <<  count  <<  ' ';

return  0;

}

**Відповідь №2.e)**

### Завдання №3

Кращим алгоритмом для визначення того, чи існує значення у відсортованому масиві, є бінарний пошук.

**Бінарний пошук працює наступним чином:**

Дивимося на центральний елемент масиву.

Якщо центральний елемент масиву більше елементу, який ми шукаємо, то все, що знаходиться праворуч від центрального елементу — відкидаємо.

Якщо центральний елемент менше елементу, який ми шукаємо, то відкидаємо все, що знаходиться ліворуч від центрального елементу.

Якщо центральний елемент дорівнює елементу, який ми шукаємо, то повертаємо індекс цього елементу.

Якщо перебрали весь масив і не знайшли шуканого значення, то повертаємо контрольне значення з повідомленням  `not found`.

Оскільки в кожній ітерації ми можемо відкидати відразу половину масиву, то швидкість виконання цього алгоритму досить висока. Навіть з масивом в мільйон елементів для визначення того, чи існує конкретне значення в цьому масиві чи ні, знадобиться не більше 20 ітерацій! Однак бінарний пошук працює тільки в відсортованому масиві.

Зміна масиву (наприклад, відкидання половини елементів масиву) є витратною операцією, тому зазвичай масив не змінюється. Замість цього використовується два цілочисельних значення (`min`  і `max`) для зберігання індексів мінімальної та максимальної меж пошуку елемента в масиві.

Розглянемо приклад роботи цього алгоритму з масивом  `{4, 5, 7, 10, 11, 14, 19, 20, 25}`  і шуканим значенням  `7`. Спочатку  `min = 0`,  `max = 8`, так як ми перебираємо весь масив (всього елементів 9, але індекс останнього елементу — 8).

_**Ітерація №1**:_  Обчислюємо середнє значення між  `min`  (0) і  `max`  (8), яке дорівнює 4. Елемент №4 має значення 11, яке більше нашого шуканого значення. Оскільки масив відсортований, то ми знаємо, що всі елементи, які знаходяться праворуч від індексу 4 (і індекс 4 теж) є більше нашого шуканого числа. Тому  `min`  залишаємо в спокої, а  `max`  змінюємо на 3.

_**Ітерація №2**:_  Обчислюємо середнє значення між  `min`  (0) і  `max`  (3), яке дорівнює 1. Елемент №1 має значення 5, яке менше нашого шуканого значення. Оскільки масив відсортований, то ми знаємо, що всі елементи, які знаходяться ліворуч від індексу 1 (і індекс 1 теж) — менше нашого шуканого числа. Отже,  `min`  змінюємо на 2, а  `max`  залишаємо в спокої.

_**Ітерація №3**:_  Обчислюємо середнє значення між  `min`  (2) і  `max`  (3), яке дорівнює 2. Елемент №2 має значення 7, яке є нашим шуканим числом. Повертаємо елемент №2.

Використовуючи наступний код:

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

// array - це масив, в якому ми проводимо пошуки.

// target - це шукане значення.

// min - це індекс мінімальної межі масиву, в якому ми проводимо пошуки.

// max - це індекс максимальної межі масиву, в якому ми проводимо пошуки.

// Функція binarySearch() повинна повертати індекс шуканого значення, якщо він виявлений. В протилежному випадку, повертаємо -1

int  binarySearch(int  *array,  int  target,  int  min,  int  max)

{

}

int  main()

{

int  array[]  =  {  4,  7,  9,  13,  15,  19,  22,  24,  28,  33,  37,  41,  43,  47,  50  };

std::cout  <<  "Enter a number: ";

int  x;

std::cin  >>  x;

int  index  =  binarySearch(array,  x,  0,  14);

if  (array[index]  ==  x)

std::cout  <<  "Good! Your value "  <<  x  <<  " is on position "<<  index  <<  " in array!\n";

else

std::cout  <<  "Fail! Your value "  <<  x  <<  " isn't in array!\n";

return  0;

}

a) Напишіть ітеративну версію функції binarySearch().

**Відповідь №3.а)**

b) Напишіть рекурсивну версію функції binarySearch().