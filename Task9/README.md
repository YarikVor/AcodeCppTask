
### Завдання №2

Напишіть клас Average, який обчислюватиме середнє значення всіх переданих йому цілих чисел. Використовуйте два члени: перший повинен бути типу int32_t і використовуватися для обчислення суми всіх переданих чисел, другий повинен бути типу int8_t і використовуватися для обчислення кількості переданих чисел. Щоб знайти середнє значення, потрібно розділити суму на кількість.

a) Наступний код функції main():

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

int  main()

{

Average avg;

avg  +=  5;

std::cout  <<  avg  <<  '\n';  // 5 / 1 = 5

avg  +=  9;

std::cout  <<  avg  <<  '\n';  // (5 + 9) / 2 = 7

avg  +=  19;

std::cout  <<  avg  <<  '\n';  // (5 + 9 + 19) / 3 = 11

avg  +=  -9;

std::cout  <<  avg  <<  '\n';  // (5 + 9 + 19 - 9) / 4 = 6

(avg  +=  7)  +=  11;  // виконання "ланцюжка" операцій

std::cout  <<  avg  <<  '\n';  // (5 + 9 + 19 - 9 + 7 + 11) / 6 = 7

Average copy  =  avg;

std::cout  <<  copy  <<  '\n';

return  0;

}

Повинен видавати наступний результат:

`5  
7  
11  
6  
7  
7`

**Відповідь №2.а)**

b) Чи потрібний цьому класу явний конструктор копіювання чи оператор присвоювання?

**Відповідь №2.b)**

### Завдання №3

Напишіть свій власний клас-масив цілих чисел IntArray (не використовуйте std::array чи std::vector). Користувачі повинні передавати розмір масиву при створенні об’єкта цього класу, а сам масив (змінна-член) повинен виділятися динамічно. Використовуйте стейтменти assert для перевірки переданих значень, а також свій конструктор копіювання і перевантаження оператора присвоювання, якщо це необхідно, щоб наступний код:

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

#include <iostream>

IntArray fillArray()

{

IntArray  a(6);

a[0]  =  6;

a[1]  =  7;

a[2]  =  3;

a[3]  =  4;

a[4]  =  5;

a[5]  =  8;

return  a;

}

int  main()

{

IntArray  a  =  fillArray();

std::cout  <<  a  <<  '\n';

IntArray  b(1);

a  =  a;

b  =  a;

std::cout  <<  b  <<  '\n';

return  0;

}

Видавав наступний результат:

`6 7 3 4 5 8  
6 7 3 4 5 8`

**Відповідь №3**

### Завдання №4

Значення типу з плаваючою крапкою — це число з десятковим дробом, де кількість цифр після крапки (дробова частина) може змінюватися. Значення типу з фіксованою крапкою — це число з дробом, де дробова частина (після крапки) фіксована.

Вам потрібно написати клас для реалізації значень типу з фіксованою крапкою з двома цифрами після крапки (наприклад,  `11.47`,  `5.00`  або  `1465.78`). Діапазон класу повинен бути від  `-32768.99`  до  `32767.99`, в дробовій частині можуть бути будь-які дві цифри, але не допускайте проблем з точністю.

a) Якого типу даних змінну-член слід використовувати для реалізації значень типу з фіксованою крапкою з двома цифрами після крапки? (Обов’язково прочитайте відповідь, перш ніж приступати до виконання наступного завдання)

**Відповідь №4.а)**

b) Напишіть клас FixedPoint, який реалізує рекомендоване рішення з попереднього завдання. Якщо дробова або ціла частини значення є від’ємними, то число повинне розглядатися, як від’ємне. Реалізуйте перевантаження необхідних операторів і напишіть необхідні конструктори, щоб наступний код функції main():

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

int  main()

{

FixedPoint  a(37,  58);

std::cout  <<  a  <<  '\n';

FixedPoint  b(-3,  9);

std::cout  <<  b  <<  '\n';

FixedPoint  c(4,  -7);

std::cout  <<  c  <<  '\n';

FixedPoint  d(-5,  -7);

std::cout  <<  d  <<  '\n';

FixedPoint  e(0,  -3);

std::cout  <<  e  <<  '\n';

std::cout  <<  static_cast<double>(e)  <<  '\n';

return  0;

}

Видавав наступний результат:

`37.58  
-3.09  
-4.07  
-5.07  
-0.03  
-0.03`

**_Підказка_:**  Для виводу значення конвертуйте його в тип double, використовуючи оператор static_cast.

**Відповідь №4.b)**

c) Тепер додайте конструктор, який прийматиме значення типу double. Ви можете округлити цілу частину (зліва від крапки) за допомогою функції round() (яка знаходиться в заголовку cmath).

**_Підказки:_**

Ви можете отримати цілу частину від числа типу double шляхом конвертації числа типу double в число типу int.

Для переміщення однієї цифри вліво від крапки використовуйте множення на 10. Для переміщення двох цифр використовуйте множення на 100.

Наступний код функції main():

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

int  main()

{

FixedPoint  a(0.03);

std::cout  <<  a  <<  '\n';

FixedPoint  b(-0.03);

std::cout  <<  b  <<  '\n';

FixedPoint  c(4.01);  // збережеться, як 4.0099999..., тому нам потрібно це все округлити

std::cout  <<  c  <<  '\n';

FixedPoint  d(-4.01);  // збережеться, як -4.0099999..., тому нам потрібно це все округлити

std::cout  <<  d  <<  '\n';

return  0;

}

Повинен видавати наступний результат:

`0.03  
-0.03  
4.01  
-4.01`

**Відповідь №4.c)**

d) Виконайте перевантаження наступних операторів:  `==`,  `>>`,  `−`  (унарний) і  `+`  (бінарний).

Наступна програма:

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

void  SomeTest()

{

std::cout  <<  std::boolalpha;

std::cout  <<  (FixedPoint(0.75)  +  FixedPoint(1.23)  ==  FixedPoint(1.98))  <<  '\n';  // обидва значення додатні, ніякого переповнення

std::cout  <<  (FixedPoint(0.75)  +  FixedPoint(1.50)  ==  FixedPoint(2.25))  <<  '\n';  // обидва значення додатні, переповнення

std::cout  <<  (FixedPoint(-0.75)  +  FixedPoint(-1.23)  ==  FixedPoint(-1.98))  <<  '\n';  // обидва значення від'ємні, ніякого переповнення

std::cout  <<  (FixedPoint(-0.75)  +  FixedPoint(-1.50)  ==  FixedPoint(-2.25))  <<  '\n';  // обидва значення від'ємні, переповнення

std::cout  <<  (FixedPoint(0.75)  +  FixedPoint(-1.23)  ==  FixedPoint(-0.48))  <<  '\n';  // друге значення від'ємне, ніякого переповнення

std::cout  <<  (FixedPoint(0.75)  +  FixedPoint(-1.50)  ==  FixedPoint(-0.75))  <<  '\n';  // друге значення від'ємне, можливе переповнення

std::cout  <<  (FixedPoint(-0.75)  +  FixedPoint(1.23)  ==  FixedPoint(0.48))  <<  '\n';  // перше значення від'ємне, ніякого переповнення

std::cout  <<  (FixedPoint(-0.75)  +  FixedPoint(1.50)  ==  FixedPoint(0.75))  <<  '\n';  // перше значення від'ємне, можливе переповнення

}

int  main()

{

SomeTest();

FixedPoint  a(-0.48);

std::cout  <<  a  <<  '\n';

std::cout  <<  -a  <<  '\n';

std::cout  <<  "Enter a number: ";  // введіть 5.678

std::cin  >>  a;

std::cout  <<  "You entered: "  <<  a  <<  '\n';

return  0;

}

Повинна видавати наступний результат:

`true  
true  
true  
true  
true  
true  
true  
true  
-0.48  
0.48  
Enter a number: 5.678  
You entered: 5.68`

**_Підказка_:** Для виконання перевантаження оператора  `>>`  використовуйте конструктор з параметром типу double для створення анонімного об’єкта класу FixedPoint, а потім присвойте цей об’єкт параметру функції перевантаження оператора  `>>`.