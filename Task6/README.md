
Вітаю вас з подоланням найдовшого розділу цього туторіалу! Якщо у вас не було попереднього досвіду в програмуванні, то цей розділ, скоріш за все, був для вас найскладнішим з усіх попередніх. Однак, якщо ви дійшли до цього моменту, то все добре — ви впоралися! Так тримати!

Гарна новина полягає в тому, що наступний розділ буде легшим, і дуже скоро ми доберемося до самого серця цього туторіалу — об’єктно-орієнтованого програмування!

Зміст:

1.  [Теорія](https://acode.com.ua/rozdil-6-pidsumkovyj-test/#toc-0)
2.  [Завдання №1](https://acode.com.ua/rozdil-6-pidsumkovyj-test/#toc-1)
3.  [Завдання №2](https://acode.com.ua/rozdil-6-pidsumkovyj-test/#toc-2)
4.  [Завдання №3](https://acode.com.ua/rozdil-6-pidsumkovyj-test/#toc-3)
5.  [Завдання №4](https://acode.com.ua/rozdil-6-pidsumkovyj-test/#toc-4)
6.  [Завдання №5](https://acode.com.ua/rozdil-6-pidsumkovyj-test/#toc-5)
7.  [Завдання №6](https://acode.com.ua/rozdil-6-pidsumkovyj-test/#toc-6)
8.  [Завдання №7](https://acode.com.ua/rozdil-6-pidsumkovyj-test/#toc-7)

## Теорія

**Масиви**  дозволяють зберігати і отримувати доступ до багатьох змінних одного і того ж типу даних через один ідентифікатор. Доступ до елементів масиву здійснюється за допомогою оператора індексу  `[]`. Будьте обережні з діапазоном масиву, не допускайте індексації елементів поза діапазоном. Масиви можна ініціалізувати за допомогою списку ініціалізаторів або uniform-ініціалізації.

**Фіксовані масиви** повинні мати довжину, встановлену під час компіляції. Фіксовані масиви конвертуються у вказівники при передачі у функцію.

Цикли використовуються для ітерації по масиву. Остерігайтеся помилок неврахованих одиниць.  **Цикли foreach**  корисні, коли масив не конвертується у вказівник.

Масиви можна зробити  **багатовимірними**, використовуючи відразу декілька індексів.

Масиви використовуються при створенні  **рядків C-style**. Уникайте використання рядків C-style, замість них використовуйте std::string.

**Вказівники** — це змінні, які зберігають адреси певних змінних в пам’яті.  **Оператор адреси** (`&`) використовується для отримання адреси змінної. Оператор розіменування (`*`) використовується для отримання значення, на яке вказує вказівник.

**Нульовий вказівник** — це вказівник, який ні на що не вказує. Вказівник можна зробити нульовим, ініціалізувавши або присвоївши йому значення  `0`  (або  `nullptr`  в C++11). Уникайте використання макросу  `NULL`. Розіменування нульового вказівника може призвести до несподіваних результатів (збою). При видаленні нульового вказівника нічого поганого не станеться.

**Вказівник на масив**  не знає довжини масиву, на який він вказує. Це означає, що оператор sizeof і цикли foreach працювати з ним не можуть.

**Оператори new і delete**  використовуються для динамічного виділення/звільнення пам’яті для вказівника, змінної або масиву. Хоча подібне трапляється вкрай рідко, оператор new може не спрацювати, якщо в операційній системі не залишиться вільної пам’яті, тому не забувайте виконувати перевірку того, чи повертає оператор new нульовий вказівник.

Обов’язково використовуйте  **оператор delete[]**  для видалення динамічно виділеного масиву. Вказівники, які вказують на звільнену пам’ять, називаються  **висячими вказівниками**. Розіменування висячого вказівника не призведе ні до чого хорошого.

Неможливість звільнити динамічно виділену пам’ять призведе до  **витоку пам’яті**, коли вказівник, який вказує на цю пам’ять, вийде з області видимості.

Для звичайних змінних пам’ять виділяється з обмеженого резервуара —  **стеку**. Пам’ять для динамічно виділених змінних виділяється із загального резервуара пам’яті —  **купи**.

**Вказівник на константне значення** обробляє значення, на яке він вказує, як константне:

```
int  value  =  7;

const  int  *ptr  =  &value;  // все нормально, ptr вказує на "const int"
```
**Константний вказівник** — це вказівник, значення якого не може бути змінено після ініціалізації:
```		
int  value  =  7;

int  *const  ptr  =  &value;
```
**Посилання**  — це псевдонім для певної змінної. Посилання оголошуються з використанням амперсанда  `&`  (в даному контексті це не оператор адреси). Для  **константних посилань**  змінити їх значення після ініціалізації не можна. Посилання використовуються для запобігання копіювання даних при їх передачі в функцію або з функції.

**Оператор вибору елемента** (`->`) може використовуватися для вибору члена через вказівник на структуру. Він поєднує в собі як операцію розіменування, так і звичайний доступ до елементів (`.`).

**Вказівник типу** **v****oid**  — це вказівник, який може вказувати на будь-який тип даних. Він не може бути розіменований напряму. Ви можете використовувати оператор static_cast для конвертування його назад у вихідний тип вказівника. Але який вже це буде тип — вирішувати вам.

**Вказівники на вказівники**  дозволяють створити вказівник, який вказує на інший вказівник.

**std::array**  надає весь функціонал стандартних фіксованих масивів в мові C++, але які при цьому не будуть конвертуватися у вказівники при передачі. Рекомендується використовувати std::array замість стандартних фіксованих масивів.

**std::vector**  надає весь функціонал динамічних масивів, але які при цьому можуть самостійно управляти виділеною їм пам’яттю і запам’ятовують свою довжину. Рекомендується використовувати std::vector замість стандартних динамічних масивів.

## Тест

### Завдання №1

Уявіть, що ви пишете гру, в якій гравець може мати 3 типи предметів: зілля здоров’я, факели і стріли. Створіть перерахування з цими типами предметів і фіксований масив для зберігання кількості кожного типу предметів, які має при собі гравець (використовуйте стандартні фіксовані масиви, а не std::array). У вашого гравця повинні бути при собі 3 зілля здоров’я, 6 факелів і 12 стріл. Напишіть функцію countTotalItems(), яка повертає загальну кількість предметів, які є у гравця. У функції main() виведіть результат виконання функції countTotalItems().

### Завдання №2

Створіть структуру, яка містить ім’я і оцінку учня (за шкалою від 0 до 100). Запитайте у користувача, скільки учнів він хоче ввести. Динамічно виділіть масив для зберігання всіх студентів. Потім попросіть користувача ввести для кожного студента його ім’я і оцінку. Як тільки користувач ввів всі імена і оцінки, відсортуйте список оцінок студентів по спаданню (спочатку найвищий бал). Потім виведіть всі імена і оцінки у відсортованому вигляді.

Для наступного вводу:

`Andre  
74  
Max  
85  
Anton  
12  
Josh  
17  
Sasha  
90`

Вивід повинен бути наступним:

`Sasha got a grade of 90  
Max got a grade of 85  
Andre got a grade of 74  
Josh got a grade of 17  
Anton got a grade of 12`

**_Підказка_:**  Ви можете змінити  [**алгоритм сортування масиву методом вибору**](https://acode.com.ua/urok-80-sortuvannya-masyviv-metodom-vyboru/)  для сортування вашого динамічного масиву. Якщо ви напишете сортування масиву окремою функцією, то масив повинен передаватися по адресі (як вказівник).

### Завдання №3

Напишіть свою функцію, яка міняє місцями значення двох цілочисельних змінних. Перевірку здійснюйте в функції main().

**_Підказка_:**  Використовуйте посилання в якості параметрів.

### Завдання №4

Напишіть функцію для виводу рядка C-style символ за символом. Використовуйте вказівник для переходу і виводу кожного символу по черзі. Зупиніть вивід при зіткненні з нуль-термінатором. У функції main() протестуйте рядок  `Hello, world!`.

**_Підказка_:**  Використовуйте оператор  `++`  для переміщення вказівника на наступний символ.

### Завдання №5

Що не так з кожним з наступних фрагментів коду, і як би ви це виправили?

a)
```
#include <iostream>

int  main()

{

int  array[6]  {  0,  2,  4,  7,  9  };

for  (int  count  =  0;  count  <=  6;  ++count)

std::cout  <<  array[count]  <<  " ";

return  0;

}
```
**Відповідь №5.a)**
```
#include <iostream>

int  main()

{

int  a  =  4;

int  b  =  6;

const  int  *ptr  =  &a;

std::cout  <<  *ptr;

*ptr  =  7;

std::cout  <<  *ptr;

ptr  =  &b;

std::cout  <<  *ptr;

return  0;

}
```

c)
```
#include <iostream>

void  printArray(int  array[])

{

for  (const  int  &element  :  array)

std::cout  <<  element  <<  ' ';

}

int  main()

{

int  array[]  {  8,  6,  4,  2,  0  };

printArray(array);

return  0;

}
```
d)
```
#include <iostream>

int  main()

{

double  d(4.7);

int  *ptr  =  &d;

std::cout  <<  ptr;

return  0;

}
```
### Завдання №6

Припустимо, що ми хочемо написати карткову гру.

a) У колоді карт знаходяться 52 унікальні карти: 13 старшинств (2, 3, 4, 5, 6, 7, 8, 9, 10, Валет, Дама, Король, Туз) і 4 масті (трефи, бубни, черви, піки). Створіть два перерахування: перше для масті, друге для старшинств.

**_Підказка_:** Додайте в кожне перерахування ще по одному елементу, який позначатиме довжину цього перерахування.

b) Кожна карта повинна бути представлена структурою  `Card`, в якій зберігається інформація про старшинство і масть карти (наприклад, 4 бубни, король трефи). Створіть цю структуру.

c) Створіть функцію printCard(), параметром якої буде константне посилання типу структури  `Card`, яка виводитиме значення старшинства і масті певної карти у вигляді 2-літерного коду (наприклад, валет піки буде виводитися як  `VP`).

d) Для представлення цілої колоди карт (52 карти) створіть масив  `deck`  (використовуючи std::array) і ініціалізуйте кожен елемент певною картою.

**_Підказка_:**  Використовуйте оператор static_cast для конвертації цілочисельної змінної у тип перерахування.

е) Напишіть функцію printDeck(), яка в якості параметру приймає константне посилання на масив  `deck`  і виводить всі значення (карти). Використовуйте цикл foreach.

f) Напишіть функцію swapCard(), яка приймає дві карти і міняє місцями їх значення.

g) Напишіть функцію shuffleDeck() для перетасовки колоди карт. Для цього використайте цикл for з ітерацією по масиву. Перетасування карт повинно відбутися 52 рази. У циклі for виберіть випадкове число від 1 до 52 і викличте функцію swapCard(), параметрами якої будуть поточна карта і рандомно вибрана карта. Додайте в функцію main() можливість перетасовки і виводу вже оновленої (перетасованої) колоди карт.

**_Підказки_:**

Для генерації випадкових чисел дивіться  [**урок №74**](https://acode.com.ua/urok-74-generatsiya-randomnyh-chysel/).

Не забудьте в початку функції main() викликати функцію srand().

Якщо ви використовуєте Visual Studio, то не забудьте перед генерацією випадкового числа викликати один раз функцію rand().

h) Напишіть функцію getCardValue(), яка повертає значення карти (наприклад, 2 означає 2, 3 означає 3 і т.д., 10, валет, дама, королева або король — це 10, туз — це 11).

### Завдання №7

Добре, настав час для серйозної гри! Давайте напишемо спрощену версію відомої карткової гри “Blackjack” (російський аналог «Очко» або «21 очко»). Якщо ви не знайомі з цією грою і її правилами, то ось посилання на статтю у Вікіпедії про  [**“Блекджек”**](https://uk.wikipedia.org/wiki/%D0%91%D0%BB%D0%B5%D0%BA%D0%B4%D0%B6%D0%B5%D0%BA).

Правила нашої версії гри “Блекджек” наступні:

спочатку дилер отримує одну карту (в реальності дилер отримує дві карти, але одна лицьовою стороною вниз, тому на даному етапі це не має значення);

гравець отримує дві карти;

гравець починає;

гравець може або “взяти” (`hit`), або “втриматися” (`stand`);

якщо гравець “втримався”, то його хід завершено, і його результат підраховується на основі карт, які у нього є;

якщо гравець “бере”, то він отримує другу карту, і значення цієї карти додається до його вже існуючого результату;

туз зазвичай рахується як 1 або 11. Щоб було простіше, ми будемо рахувати його як 11;

якщо у гравця в результаті виходить більше 21, то він програв;

хід дилера виконується після ходу гравця;

дилер бере карти до тих пір, поки його загальний результат не досягне 17 або більше очок. Як тільки ця межа досягнута — дилер карт вже не бере;

якщо у дилера більше 21, то дилер програв, а гравець виграв;

якщо ж у дилера і у гравця до 21 очка, то виграв той, у кого більший результат.

У нашій спрощеній версії гри “Blackjack” ми не будемо відслідковувати, які конкретно карти були у гравця, а які у дилера. Ми будемо відслідковувати тільки суму значень карт, які вони отримали. Так буде простіше.

Почнемо з коду, який ми отримали в завданні №6. Створіть функцію playBlackjack(), яка повертає  `true`, якщо гравець перемагає, і  `false`  — якщо гравець програє. Ця функція повинна:

Приймати перетасовану колоду карт (`deck`) в якості параметру.

Ініціалізувати вказівник на першу карту (ім’я вказівника —  `cardPtr`). Це буде використовуватися для роздачі карт з колоди.

Мати дві цілочисельні змінні для зберігання результату гравця і дилера.

Відповідати правилам, наведеним вище.

**_Підказка:_**  Найпростіший спосіб роздачі карт з колоди — це змусити вказівник вказувати на наступну карту в колоді (яка роздаватиметься). Всякий раз, коли нам потрібно буде роздати карту, ми отримуємо значення поточної карти, а потім змушуємо вказівник вказувати на наступну карту. Це можна зробити наступним рядком коду:

1

getCardValue(*cardPtr++);

Тут повертається значення поточної карти (яке потім може бути додано до загального результату гравця або дилера) і вказівник  `cardPtr`  переходить до наступної карти.

Протестуйте виконання одиночної гри «Блекджек» у функції main().
