## Тест

### Завдання №1

Уявіть, що ви пишете гру, в якій гравець може мати 3 типи предметів: зілля здоров’я, факели і стріли. Створіть перерахування з цими типами предметів і фіксований масив для зберігання кількості кожного типу предметів, які має при собі гравець (використовуйте стандартні фіксовані масиви, а не std::array). У вашого гравця повинні бути при собі 3 зілля здоров’я, 6 факелів і 12 стріл. Напишіть функцію countTotalItems(), яка повертає загальну кількість предметів, які є у гравця. У функції main() виведіть результат виконання функції countTotalItems().

### Завдання №2

Створіть структуру, яка містить ім’я і оцінку учня (за шкалою від 0 до 100). Запитайте у користувача, скільки учнів він хоче ввести. Динамічно виділіть масив для зберігання всіх студентів. Потім попросіть користувача ввести для кожного студента його ім’я і оцінку. Як тільки користувач ввів всі імена і оцінки, відсортуйте список оцінок студентів по спаданню (спочатку найвищий бал). Потім виведіть всі імена і оцінки у відсортованому вигляді.

Для наступного вводу:

```
Andre  
74  
Max  
85  
Anton  
12  
Josh  
17  
Sasha  
90
```

Вивід повинен бути наступним:

```
Sasha got a grade of 90  
Max got a grade of 85  
Andre got a grade of 74  
Josh got a grade of 17  
Anton got a grade of 12
```

**_Підказка_:**  Ви можете змінити  [**алгоритм сортування масиву методом вибору**](https://acode.com.ua/urok-80-sortuvannya-masyviv-metodom-vyboru/)  для сортування вашого динамічного масиву. Якщо ви напишете сортування масиву окремою функцією, то масив повинен передаватися по адресі (як вказівник).

### Завдання №3

Напишіть свою функцію, яка міняє місцями значення двох цілочисельних змінних. Перевірку здійснюйте в функції main().

**_Підказка_:**  Використовуйте посилання в якості параметрів.

### Завдання №4

Напишіть функцію для виводу рядка C-style символ за символом. Використовуйте вказівник для переходу і виводу кожного символу по черзі. Зупиніть вивід при зіткненні з нуль-термінатором. У функції main() протестуйте рядок  `Hello, world!`.

**_Підказка_:**  Використовуйте оператор  `++`  для переміщення вказівника на наступний символ.

### Завдання №6

Припустимо, що ми хочемо написати карткову гру.

a) У колоді карт знаходяться 52 унікальні карти: 13 старшинств (2, 3, 4, 5, 6, 7, 8, 9, 10, Валет, Дама, Король, Туз) і 4 масті (трефи, бубни, черви, піки). Створіть два перерахування: перше для масті, друге для старшинств.

**_Підказка_:** Додайте в кожне перерахування ще по одному елементу, який позначатиме довжину цього перерахування.

b) Кожна карта повинна бути представлена структурою  `Card`, в якій зберігається інформація про старшинство і масть карти (наприклад, 4 бубни, король трефи). Створіть цю структуру.

c) Створіть функцію printCard(), параметром якої буде константне посилання типу структури  `Card`, яка виводитиме значення старшинства і масті певної карти у вигляді 2-літерного коду (наприклад, валет піки буде виводитися як  `VP`).

d) Для представлення цілої колоди карт (52 карти) створіть масив  `deck`  (використовуючи std::array) і ініціалізуйте кожен елемент певною картою.

**_Підказка_:**  Використовуйте оператор static_cast для конвертації цілочисельної змінної у тип перерахування.

е) Напишіть функцію printDeck(), яка в якості параметру приймає константне посилання на масив  `deck`  і виводить всі значення (карти). Використовуйте цикл foreach.

f) Напишіть функцію swapCard(), яка приймає дві карти і міняє місцями їх значення.

g) Напишіть функцію shuffleDeck() для перетасовки колоди карт. Для цього використайте цикл for з ітерацією по масиву. Перетасування карт повинно відбутися 52 рази. У циклі for виберіть випадкове число від 1 до 52 і викличте функцію swapCard(), параметрами якої будуть поточна карта і рандомно вибрана карта. Додайте в функцію main() можливість перетасовки і виводу вже оновленої (перетасованої) колоди карт.

**_Підказки_:**

Для генерації випадкових чисел дивіться  [**урок №74**](https://acode.com.ua/urok-74-generatsiya-randomnyh-chysel/).

Не забудьте в початку функції main() викликати функцію srand().

Якщо ви використовуєте Visual Studio, то не забудьте перед генерацією випадкового числа викликати один раз функцію rand().

h) Напишіть функцію getCardValue(), яка повертає значення карти (наприклад, 2 означає 2, 3 означає 3 і т.д., 10, валет, дама, королева або король — це 10, туз — це 11).

### Завдання №7

Добре, настав час для серйозної гри! Давайте напишемо спрощену версію відомої карткової гри “Blackjack” (російський аналог «Очко» або «21 очко»). Якщо ви не знайомі з цією грою і її правилами, то ось посилання на статтю у Вікіпедії про  [**“Блекджек”**](https://uk.wikipedia.org/wiki/%D0%91%D0%BB%D0%B5%D0%BA%D0%B4%D0%B6%D0%B5%D0%BA).

Правила нашої версії гри “Блекджек” наступні:

спочатку дилер отримує одну карту (в реальності дилер отримує дві карти, але одна лицьовою стороною вниз, тому на даному етапі це не має значення);

гравець отримує дві карти;

гравець починає;

гравець може або “взяти” (`hit`), або “втриматися” (`stand`);

якщо гравець “втримався”, то його хід завершено, і його результат підраховується на основі карт, які у нього є;

якщо гравець “бере”, то він отримує другу карту, і значення цієї карти додається до його вже існуючого результату;

туз зазвичай рахується як 1 або 11. Щоб було простіше, ми будемо рахувати його як 11;

якщо у гравця в результаті виходить більше 21, то він програв;

хід дилера виконується після ходу гравця;

дилер бере карти до тих пір, поки його загальний результат не досягне 17 або більше очок. Як тільки ця межа досягнута — дилер карт вже не бере;

якщо у дилера більше 21, то дилер програв, а гравець виграв;

якщо ж у дилера і у гравця до 21 очка, то виграв той, у кого більший результат.

У нашій спрощеній версії гри “Blackjack” ми не будемо відслідковувати, які конкретно карти були у гравця, а які у дилера. Ми будемо відслідковувати тільки суму значень карт, які вони отримали. Так буде простіше.

Почнемо з коду, який ми отримали в завданні №6. Створіть функцію playBlackjack(), яка повертає  `true`, якщо гравець перемагає, і  `false`  — якщо гравець програє. Ця функція повинна:

Приймати перетасовану колоду карт (`deck`) в якості параметру.

Ініціалізувати вказівник на першу карту (ім’я вказівника —  `cardPtr`). Це буде використовуватися для роздачі карт з колоди.

Мати дві цілочисельні змінні для зберігання результату гравця і дилера.

Відповідати правилам, наведеним вище.

**_Підказка:_**  Найпростіший спосіб роздачі карт з колоди — це змусити вказівник вказувати на наступну карту в колоді (яка роздаватиметься). Всякий раз, коли нам потрібно буде роздати карту, ми отримуємо значення поточної карти, а потім змушуємо вказівник вказувати на наступну карту. Це можна зробити наступним рядком коду:

`getCardValue(*cardPtr++);`

Тут повертається значення поточної карти (яке потім може бути додано до загального результату гравця або дилера) і вказівник  `cardPtr`  переходить до наступної карти.

Протестуйте виконання одиночної гри «Блекджек» у функції main().
